### 1. 事务四特性

   **l 原子性**：一个事务中所有对数据库的操作是一个不可分割的操作序列，要么全做，要么全不做

   l **一致性**：数据库从一个正确的状态变为另一个正确的状态

   l **隔离性**：一个事务的执行，不受其他事务的干扰

   l **持久性**：事务一旦提交，对数据库的改变是永久的

### 2. 事务存在问题

   #### l **脏读**

   所谓的脏读，其实就是读到了别的事务未提交前的脏数据。

   #### l **不可重复读**

   不可重复读字面含义已经很明了了，比如事务A首先读取了一条数据，然后执行逻辑的时候，事务B将这条数据改变了或者删除了，然后事务A再次读取的时候，发现数据不匹配了。(update、delete 带来的问题)

   #### l **幻读**

   幻读也是这样子，事务A首先根据条件索引得到10条数据，然后事务insert了一条数据，这样事务A再次搜索发现有11条数据了，就产生了幻读。（insert 带来的问题）

*幻读包括delete吗？*

> The so-called phantom problem occurs within a transaction when the same query produces different sets of rows at different times. For example, if a [`SELECT`](https://segmentfault.com/a/1190000025156465#)) is executed twice, but returns a row the second time that was not returned the first time, the row is a “phantom” row.
>
> https://dev.mysql.com/doc/refman/5.7/en/innodb-next-key-locking.html

<font color=yellow>`幻读针对的是结果集前后发生变化，所以看起来delete的情况应该归为幻读，但是我们实际分析下上面列出的标准SQL在RR级别的实现原理就知道，标准SQL的RR级别是会对查到的数据行加行共享锁，所以这时候其他事务想删除这些数据行其实是做不到的，所以在RR下，不会出现因delete而出现幻读现象，也就是幻读不包含delete的情况`</font>

### 3. 隔离性

#### l **SERIALIZABLE**

   最严格的级别，事务串行执行，资源消耗最大。

   #### l **REPEATABLE_READ**

   保证了一个事务不会修改已经由另一个事务读取但未提交（回滚）的数据。避免了“脏读取”和“不可重复读取”的情况，但是带来了更多的性能损失。

#### l **READ_COMMITTED**

   大多数主流数据库的默认事务等级，保证了一个事务不会读到另一个并行事务已修改但未提交的数据，避免了“脏读取”。该级别适用于大多数系统。

#### l **READ_UNCOMMITTED**

   保证了读取过程中不会读取到非法数据。

| 隔离级别                     | 脏读   | 不可重复读 | 幻读                                                         |
| :--------------------------- | :----- | :--------- | :----------------------------------------------------------- |
| 未提交读（Read uncommitted） | 可能   | 可能       | 可能                                                         |
| 已提交读（Read committed）   | 不可能 | 可能       | 可能                                                         |
| 可重复读（Repeatable read）  | 不可能 | 不可能     | <font color=red>可能，但是mysql的innodb通过间隙锁解决了这个问题，不可能出现幻读</font> |
| 可串行化（Serializable ）    | 不可能 | 不可能     | 不可能                                                       |

### 4. 事务隔离级别的实现原理

| 事务隔离级别   | 实现方式                                                     |
| -------------- | ------------------------------------------------------------ |
| 未提交读（RU） | 事务对当前被读取的数据不加锁；  事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加**行级共享锁**，直到事务结束才释放。 |
| 提交读（RC）   | 事务对当前被读取的数据加**行级共享锁（当读到时才加锁）**，一旦读完该行，立即释放该行级共享锁；  事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加**行级排他锁**，直到事务结束才释放。 |
| 可重复读（RR） | 事务在读取某数据的瞬间（就是开始读取的瞬间），必须先对其加**行级共享锁**，直到事务结束才释放；  事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加**行级排他锁**，直到事务结束才释放。 |
| 序列化读（S）  | 事务在读取数据时，必须先对其加**表级共享锁** ，直到事务结束才释放；  事务在更新数据时，必须先对其加**表级排他锁** ，直到事务结束才释放。 |
### 5. 当前读与快照读

MVCC(多版本并发控制，替代共享锁提高读取性能)的具体操作：

> SELECT时，读取创建版本号<=当前事务版本号，删除版本号为空或>当前事务版本号。
> INSERT时，保存当前事务版本号为行的创建版本号
> DELETE时，保存当前事务版本号为行的删除版本号
> UPDATE时，插入一条新纪录，保存当前事务版本号为行创建版本号，同时保存当前事务版本号到原来删除的行

快照读(通过MVCC实现)：就是select，
>select * from table ....;

当前读：特殊的读操作，插入/更新/删除操作，属于当前读，处理的都是当前的数据，需要加锁。

> select * from table where ? lock in share mode;
> select * from table where ? for update;
> insert;
> update ;
> delete;

### 6. 引入快照读、间隙锁后事务隔离级别的实现原理

| 事务隔离级别   | 实现方式                                                     |
| -------------- | ------------------------------------------------------------ |
| 未提交读（RU） | 事务对当前被读取的数据是**当前读**；  事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加**行级共享锁**，直到事务结束才释放。 |
| 提交读（RC）   | 事务对当前被读取的数据不加锁，且是**快照读**；  事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加**行级排他锁（Record）**，直到事务结束才释放。  **通过快照，在这个级别MySQL就解决了不可重复读的问题** |
| 可重复读（RR） | 事务对当前被读取的数据不加锁，且是**快照读**；  事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加**行级排他锁【Record，GAP(间隙锁)，Next-Key(GAP+行锁组合)】**，直到事务结束才释放。  **通过间隙锁，在这个级别MySQL就解决了幻读的问题** |
| 序列化读（S）  | 事务在读取数据时，必须先对其加**表级共享锁** ，直到事务结束才释放，都是**当前读**；  事务在更新数据时，必须先对其加**表级排他锁** ，直到事务结束才释放。 |

