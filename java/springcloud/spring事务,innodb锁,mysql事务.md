1. 事务四特性

   **l 原子性**：一个事务中所有对数据库的操作是一个不可分割的操作序列，要么全做，要么全不做

   l **一致性**：数据库从一个正确的状态变为另一个正确的状态

   l **隔离性**：一个事务的执行，不受其他事务的干扰

   l **持久性**：事务一旦提交，对数据库的改变是永久的

2. 事务存在问题

    #### l **脏读**
   
    所谓的脏读，其实就是读到了别的事务回滚前的脏数据。比如事务B执行过程中修改了数据X，在未提交前，事务A读取了X，而事务B却回滚了，这样事务A就形成了脏读。
   
    #### l **不可重复读**
   
    不可重复读字面含义已经很明了了，比如事务A首先读取了一条数据，然后执行逻辑的时候，事务B将这条数据改变了，然后事务A再次读取的时候，发现数据不匹配了，就是所谓的不可重复读了。
   
    #### l **幻读**
   
    幻读也是这样子，事务A首先根据条件索引得到10条数据，然后事务B改变了数据库一条数据，导致也符合事务A当时的搜索条件，这样事务A再次搜索发现有11条数据了，就产生了幻读。
   
3. 隔离性

    #### l **SERIALIZABLE**

    最严格的级别，事务串行执行，资源消耗最大。

    #### l **REPEATABLE_READ**

    保证了一个事务不会修改已经由另一个事务读取但未提交（回滚）的数据。避免了“脏读取”和“不可重复读取”的情况，但是带来了更多的性能损失。

    #### l **READ_COMMITTED**

    大多数主流数据库的默认事务等级，保证了一个事务不会读到另一个并行事务已修改但未提交的数据，避免了“脏读取”。该级别适用于大多数系统。

    #### l **READ_UNCOMMITTED**

    保证了读取过程中不会读取到非法数据。

    | 隔离级别                     | 脏读   | 不可重复读 | 幻读   |
    | :--------------------------- | :----- | :--------- | :----- |
    | 未提交读（Read uncommitted） | 可能   | 可能       | 可能   |
    | 已提交读（Read committed）   | 不可能 | 可能       | 可能   |
    | 可重复读（Repeatable read）  | 不可能 | 不可能     | 可能   |
    | 可串行化（Serializable ）    | 不可能 | 不可能     | 不可能 |

4. mysql锁   https://developer.ibm.com/zh/technologies/databases/articles/os-mysql-transaction-isolation-levels-and-locks/

    https://blog.csdn.net/a837199685/article/details/54563740

5. @Transactional注解只能作用在public方法上，原因：private/protected方法对代理类不可见

6. spring事务 非运行时异常能否回滚？

7. service类内部调用事务注解不生效解决（强制使用AspectJ代理）

8. 事务传播性  https://www.cnblogs.com/duanxz/p/4746892.html

    #### l **PROPAGATION_REQUIRED**

    <font color='red'>默认的Spring事务传播级别</font>，如果上下文中已经存在事务，那么就加入到事务中执行；如果当前上下文中不存在事务，则新建事务执行。所以这个级别通常能满足处理大多数的业务场景。

    #### l **PROPAGATION_SUPPORTS**

    如果上下文存在事务，则支持事务加入事务，如果没有事务，则使用非事务的方式执行。所以说，并非所有的包含在TransactionTemplate.execute方法中的代码都会有事务支持。这个通常是用来处理那些并非原子性的非核心业务逻辑操作。应用场景较少。

    #### l **PROPAGATION_MANDATORY**

    该级别的事务要求上下文中必须要存在事务，否则就会抛出异常！配置该方式的传播级别是有效的控制上下文调用代码遗漏添加事务控制的保证手段。比如一段代码不能单独被调用执行，但是一旦被调用，就必须有事务包含的情况，就可以使用这个传播级别。

    #### l **PROPAGATION_REQUIRES_NEW**

    从字面即可知道，new，每次都要一个新事务，该传播级别的特点是：每次都会新建一个事务，并且同时将上下文中的事务挂起，执行当前新建事务完成以后，上下文事务恢复再执行。

    这是一个很有用的传播级别，举一个应用场景：现在有一个发送100个红包的操作，在发送之前，要做一些系统的初始化、验证、数据记录操作，然后发送100封红包，然后再记录发送日志，发送日志要求100%的准确，如果日志不准确，那么整个父事务逻辑需要回滚。

    怎么处理整个业务需求呢？就是通过这个PROPAGATION_REQUIRES_NEW级别的事务传播控制就可以完成。发送红包的子事务不会直接影响到父事务的提交和回滚。

    #### l **PROPAGATION_NOT_SUPPORTED**

    这个也可以从字面得知，not supported，不支持，当前级别的特点是：若上下文中存在事务，则挂起事务，执行当前逻辑，结束后恢复上下文的事务。

    这个级别有什么好处？可以帮助你将事务尽可能的缩小。我们知道一个事务越大，它存在的风险也就越多。所以在处理事务的过程中，要保证尽可能的缩小范围。比如一段代码，是每次逻辑操作都必须调用的，比如循环1000次的某个非核心业务逻辑操作。这样的代码如果包在事务中，势必造成事务太大，导致出现一些难以考虑周全的异常情况，所以事务的这个传播级别就派上用场了。用当前级别的事务模板包含起来就可以了。

    #### l **PROPAGATION_NEVER**

    该事务更严格，上面一个事务传播级别只是不支持而已，有事务就挂起，而PROPAGATION_NEVER传播级别要求上下文中不能存在事务，一旦有事务，就抛出runtime异常，强制停止执行！这个级别上辈子跟事务有仇。

    #### l **PROPAGATION_NESTED**
