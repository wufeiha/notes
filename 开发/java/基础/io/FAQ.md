## 同异步、阻塞、非阻塞

- **同步：** 同步就是发起一个调用后，被调用者未处理完请求之前，调用不返回。
- **异步：** 异步就是发起一个调用后，立刻得到被调用者的回应表示已接收到请求，但是被调用者并没有返回结果，此时我们可以处理其他的请求，被调用者通常依靠事件，回调等机制来通知调用者其返回结果。

- **阻塞：** 阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。
- **非阻塞：** 非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他事情。

## IO分类

### **同步阻塞IO（BIO）：**

> 在此种方式下，用户进程在发起一个IO操作以后，必须等待IO操作的完成，只有当真正完成了IO操作以后，用户进程才能运行。JAVA传统的IO模型属于此种方式！

### **同步非阻塞IO（NIO）:**

> 在此种方式下，用户进程发起一个IO操作以后便可返回做其它事情，但是用户进程需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问，从而引入不必要的CPU资源浪费。其中目前JAVA的NIO就属于同步非阻塞IO。

### **异步阻塞IO（NIO）：**

> 此种方式下是指应用发起一个IO操作以后，不等待内核IO操作的完成，等内核完成IO操作以后会通知应用程序，这其实就是同步和异步最关键的区别，同步必须等待或者主动的去询问IO是否完成，那么为什么说是阻塞的呢？因为此时是通过select系统调用来完成的，而select函数本身的实现方式是阻塞的，而采用select函数有个好处就是它可以同时监听多个文件句柄，从而提高系统的并发性！

### **异步非阻塞IO（AIO）:**

> 在此种模式下，用户进程只需要发起一个IO操作然后立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的IO读写操作，因为真正的IO读取或者写入操作已经由内核完成了。

### 直接内存受jvm管理吗

直接内存本身不受gc的影响，但是由于有对象在堆引用这这块内存，那么受到gc的间接影响，

### java普通io与其他io（c、c++方式）的区别

#### java普通io过程

比无虚拟机语言多一层JVM内外拷贝。

![img](https://blog.ayang818.top/large-file-I-O-in-java/1.png)

#### 无虚拟机语言io过程

![截屏2021-06-24 16.02.15](https://i.loli.net/2021/06/24/T95PchwjUJqMKEO.png)

![img](https://s2.loli.net/2022/03/24/xTn1Khbf5CrMsHt.png)

#### mmap

![img](https://s2.loli.net/2022/03/24/M3LRo2wXI1x6NeP.png)

#### 零拷贝

![img](https://s2.loli.net/2022/03/24/z5TeudIwaYho1gn.png)

**读取**

1.用户空间向内核空间发出指令——我要读取文件a
2.系统切换上下文，从用户空间切到内核空间，内核空间准备向硬盘读取内容
3.硬盘内容以DMA形式读取进内核缓冲区（tips:DMA——Directory Memory Access 直接内存访问）
4.系统切换上下文，从内核空间切到用户空间，把内核空间的缓冲区的内容写入用户缓冲区
5.业务逻辑处理

**写入**
6.准备写入b文件，用户空间向内核空间发出指令——我要写文件b，并且把用户缓冲区的内容写入内核缓冲区
7.系统切换上下文，从用户空间切到内核空间，内核空间准备向硬盘写入内容
8.写入成功，系统返回
9.系统切换上下文，从内核空间切到用户空间，内容写入完毕

## IO优化的目标

- 榨干`CPU`的性能，减少IO期间`CPU`的参与，让`CPU`更多的去执行计算任务。
- 减少IO读取或写入过程中数据拷贝次数，加快IO速度。