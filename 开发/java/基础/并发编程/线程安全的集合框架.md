以下所说的无界队列不是真正的长度无限制，都在jvm限制内，一般长度为Integer.MAX_VALUE以内，不同系统可能比这个值略小，当前机器（macos pro 2019 ,inter i9,16g）最大长度为Integer.MAX_VALUE-8。ConcurrentLinkedQueue、ConcurrentLinkedDeque是真正的无界队列。<font color=red>类似`addAll()`等聚合方法慎用，可能线程不安全。</font>

# 符号表

## ConcurrentHashMap

#### 特点

- key、value都不允许null值
- 容量、扩容问题参考HashMap
- 读取无锁，通过volatile保证可见性

##### JDK1.7

和hashmap一样，在jdk1.7中ConcurrentHashMap的底层数据结构是数组加链表。和hashmap不同的是ConcurrentHashMap中存放的数据是一段段的，即由多个Segment(段)组成的。每个Segment中都有着类似于数组加链表的结构。

###### 关于Segment

concurrencyLevel：并发级别，默认16

其中并发级别控制了Segment的个数，在一个ConcurrentHashMap创建后Segment的个数是不能变的，扩容过程过改变的是每个Segment的大小(Segment内部扩容机制参考HashMap)。

###### 关于分段锁

段Segment继承了重入锁ReentrantLock，有了锁的功能，每个锁控制的是一段，当每个Segment越来越大时，锁的粒度就变得有些大了。

- 分段锁的优势在于保证在操作不同段 map 的时候可以并发执行，操作同段 map 的时候，进行锁的竞争和等待。这相对于直接对整个map同步synchronized是有优势的。
- 缺点在于分成很多段时会比较浪费内存空间(不连续，碎片化); 操作map时竞争同一个分段锁的概率非常小时，分段锁反而会造成更新等操作的长时间等待; 当某个段很大时，分段锁的性能会下降

##### JDK1.8

和hashmap一样,jdk 1.8中ConcurrentHashmap采用的底层数据结构为数组+链表+红黑树的形式。数组可以扩容，链表可以转化为红黑树。

###### 什么时候扩容？

1. 当前容量超过阈值
2. 当链表中元素个数超过默认设定（8个），当数组的大小还未超过64的时候，此时进行数组的扩容，如果超过则将链表转化成红黑树

###### 什么时候链表转化为红黑树？

当数组大小已经超过64并且链表中的元素个数超过默认设定（8个）时，将链表转化为红黑树

ConcurrentHashMap的put操作代码如下:

![截屏2021-06-22 17.26.37](https://i.loli.net/2021/06/22/3VvsIUqc1BHazJg.png)

把数组中的每个元素看成一个桶。可以看到大部分都是CAS操作，加锁的部分是对桶的头节点进行加锁，锁粒度很小。

###### 为什么不用ReentrantLock而用synchronized ?

- 减少内存开销:如果使用ReentrantLock则需要节点继承AQS来获得同步支持，增加内存开销，而1.8中只有头节点需要进行同步。
- 内部优化:synchronized则是JVM直接支持的，JVM能够在运行时作出相应的优化措施：锁粗化、锁消除、锁自旋等等。

## ConcurrentSkipListMap

#### 特点

- 基于链表的跳表(空间换时间)实现的有序表

- 元素必须实现`Comparable`接口，或者提供比较器，否则按默认顺序。

- Key、value都不允许null值

- 对于单链表，即使链表是有序的，如果想要在其中查找某个数据，也只能从头到尾遍历链表，这样效率自然就会很低，跳表就不一样了。跳表是一种可以用来快速查找的数据结构，有点类似于平衡树。它们都可以对元素进行快速的查找。但一个重要的区别是：**对平衡树的插入和删除往往很可能导致平衡树进行一次全局的调整；而对跳表的插入和删除，只需要对整个数据结构的局部进行操作即可**。这样带来的好处是：**在高并发的情况下，需要一个全局锁，来保证整个平衡树的线程安全；而对于跳表，则只需要部分锁即可**。这样，在高并发环境下，就可以拥有更好的性能。就查询的性能而言，跳表的时间复杂度是 O(logn)。

- 每往上一层链表，都是下面一层的子集

  <img src="https://i.loli.net/2021/06/23/jDPlFywhLZnr3tR.png" alt="img" style="zoom: 67%;" />

  <img src="https://i.loli.net/2021/06/23/XrxdoNvGz4DMCAp.png" alt="img" style="zoom:50%;" />

#### 应用场景

线程安全版本的TreeMap

# 集合

## ConcurrentSkipListSet

#### 特点

- 底层使用ConcurrentSkipListMap，使用的key健，value是Boolean类型

## CopyOnWriteArraySet

#### 特点

- 底层使用CopyOnWriteArrayList，只是添加元素使用（如果存在就不添加），保证不重复。

#### 应用场景

读写分离，适用于读多写少的情况，最大程度的提高读的效率。CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。

# 列表

## CopyOnWriteArrayList

#### 特点

- init_capacity = 0；max_capacity = capacity(默认为Integer.MAX_VALUE，受限于机器，比改值小)，没有数组扩容一说，因为每次修改都会创建一个新的<font color=red>数组</font>
- <font color=red>读取无锁：</font>CopyOnWriteArrayList 利用了“不变性”原理，因为容器每次修改都是创建新副本（不直接修改当前容器，而是先将当前容器进行 Copy，复制出一个新的容器，然后修改新的容器，完成修改之后，再将原容器的引用指向新的容器），所以对于旧容器来说，其实是不可变的，也是线程安全的，无需进一步的同步操作。我们可以对 CopyOnWrite 容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素，也不会有修改
- 线程安全版ArrayList，非公平锁
- 支持null元素
- **数据一致性问题**。CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器
- **内存占用问题**。因为CopyOnWrite的写时复制机制，对GC压力比较大。

#### 应用场景

读写分离，适用于读多写少的情况，最大程度的提高读的效率。CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。

# 队列

## 单边队列

### LinkedBlockingDueue

#### 特点

- init_capacity = 0；max_capacity = capacity(默认为Integer.MAX_VALUE，受限于机器，比该值小)
- LinkedBlockingQueue是一个单向链表实现的阻塞有界队列，默认无界。该队列按 FIFO排序元素。
- <font color=red>链接队列的吞吐量通常要高于基于数组的队列，但是在大多数并发应用程序中，其可预知的性能要低（可预知性能低指的是相对数组结构链表使用的内存空间是动态分配的，内存方面性能稍差）。</font>
- 内部使用两个可重入锁（都是非公平锁，没有提供使用公平锁的选项），分别管理读取线程及写入线程，当前队列为空时，会阻塞消费数据的线程，直至队列非空时，通知被阻塞的线程；当队列满时，会阻塞插入数据的线程，直至队列未满时，通知插入数据的线程（生产者线程）
- 队列不支持null元素

<img src="https://i.loli.net/2021/06/18/OhAJs71Lf35aMiC.png" alt="截屏2021-06-18 04.16.24" style="zoom:50%;" />

#### 函数

除以下方法之外，其他方法慎用，可能线程不安全。以下所说的读写锁是指写入线程锁及读取线程锁，并不是真正的读写锁，使用的是`ReentrantLock`对象，读锁并不共享。

- <font color=red>`put()`</font> 写入数据，阻塞（可被打断）其他写入线程，内部调用notFull.await()，会一直等待直到队列有空间，所以写入一定会成功。
- <font color=red>`take()`</font> 读取数据，阻塞（可被打断）其他读取线程，内部调用notEmpty.await()，会一直等待直到队列有数据，所以一定会读到数据。
- <font color=orange>`offer()`</font> 写入数据立即返回，可能会写入失败，因为未调用notFull.await()，阻塞（不可被打断）其他写入线程，成功返回true，否则返回false。
- <font color=orange>`offer(time, TimeUnit.SECONDS)`</font> 写入数据time时间返回，可能会写入失败，因为调用notFull.await(time)，阻塞（可被打断）其他写入线程，成功返回true，否则返回false
- <font color=orange>`add()`</font> 放数据立即返回，可能会写入失败，内部调用`offer()`，成功返回true，失败抛出异常。
- <font color=orange>`poll()`</font> 读取数据立即返回，可能会读取失败，因为未调用notEmpty.await()，阻塞（不可被打断）其他读取线程，成功返回数据，否则返回null。
- <font color=orange>`poll(2000, TimeUnit.SECONDS)`</font> 读取数据time时间返回，可能会读取失败，因为调用notEmpty.await(time)，阻塞（可被打断）其他读取线程，成功返回数据，否则返回null
- <font color=orange>`drainTo(Collection c)`</font>排空，即读取所有数据放入集合c,并移除这些数据
- <font color=orange>`drainTo(Collection c, int maxElements)`</font>排空，即读取maxElements个数据放入集合c,并移除这些数据
- <font color=orange>`iterator() `</font>读写双锁，迭代器
- <font color=orange>`spliterator()`</font>
- <font color=orange>`peek() `</font>阻塞（不可被打断）其他写入线程，只是读取元素，但是不删除元素，返回数据或者null
- <font color=orange>`contains()`</font>读写双锁（不可被打断），判断是否包含
- <font color=orange>`toArray()`</font>读写双锁（不可被打断），转数组
- <font color=orange>`isEmpty()`</font>原子类保证线程安全
- <font color=orange>`size()`</font>返回元素个数，原子类保证线程安全
- <font color=orange>`remainingCapacity() `</font>返回剩余容量，原子类保证线程安全
- <font color=orange>`remove()`</font>读写双锁（不可被打断），删除某个元素
- <font color=orange>`clear()`</font>读写双锁（不可被打断），删除所有元素

#### 应用场景

处理多线程间的生产者消费者问题

- Executors.newFixedThreadPool线程池
- Executors.newSingleThreadExecutor线程池

#### LinkedBlockingQueue vs ArrayBlockingQueue

- ArrayBlockingQueue是一个基于数组的；而LinkedBlockingQueue是基于链表的
- ArrayBlockingQueue可以控制对象的内部锁是否采用公平锁，默认采用非公平锁；而LinkedBlockingQueue是不可控制内部锁是否采用公平锁，默认也是非公平锁
- ArrayBlockingQueue与LinkedBlockingQueue间还有一个明显的不同之处在于，前者在插入或删除元素时不会产生或销毁任何额外的对象实例，而后者则会生成一个额外的Node对象。这在长时间内需要高效并发地处理大批量数据的系统中，其对于GC的影响还是存在一定的区别
- LinkedBlockingQueue应该具有更好的吞吐量，因为它为头部和尾部使用了单独的锁，ArrayBlockingQueue在生产者放入数据和消费者获取数据，都是共用同一个锁对象**，**由此也意味着两者无法真正并行运行，这点尤其不同于LinkedBlockingQueue；**按照实现原理来分析，ArrayBlockingQueue完全可以采用分离锁，从而实现生产者和消费者操作的完全并行运行。Doug Lea之所以没这样去做，也许是因为ArrayBlockingQueue的数据写入和获取操作已经足够轻巧，以至于引入独立的锁机制，除了给代码带来额外的复杂性外，其在性能上完全占不到任何便宜。 **
- 由于数据结构不同的原因，ArrayBlockingQueue的内存分配是一早定好的，因此它在使用期间不会分配节点，但会立即占用相当大的内存块，如果内存碎片化，则可能会出现问题；而LinkedBlockingQueue内存是动态分配的，这也意味着它将为分配和释放节点带来一些工作，对JVM有一定的压力。

### ArrayBlockingDueue

#### 特点

- init_capacity = max_capacity = capacity

- ArrayBlockingQueue是一个基于数组的阻塞式的先进先出的有界队列，初始化时需要指定的队列容量，就是该队列的最大容量，队列中容量达到最大值时不会扩容，则会阻塞队列。

- 队列不支持null元素

- ArrayBlockingQueue在生产者放入数据和消费者获取数据，都是共用同一个锁对象**，**由此也意味着两者无法真正并行运行，这点尤其不同于LinkedBlockingQueue；**按照实现原理来分析，ArrayBlockingQueue完全可以采用分离锁，从而实现生产者和消费者操作的完全并行运行。Doug Lea之所以没这样去做，也许是因为ArrayBlockingQueue的数据写入和获取操作已经足够轻巧，以至于引入独立的锁机制，除了给代码带来额外的复杂性外，其在性能上完全占不到任何便宜。 **

- ArrayBlockingQueue与LinkedBlockingQueue间还有一个明显的不同之处在于，前者在插入或删除元素时不会产生或销毁任何额外的对象实例，而后者则会生成一个额外的Node对象。这在长时间内需要高效并发地处理大批量数据的系统中，其对于GC的影响还是存在一定的区别。

- 可以控制对象的内部锁是否采用公平锁，默认采用非公平锁

  <img src="https://i.loli.net/2021/06/18/MDe2U6ga9uOFicR.png" alt="截屏2021-06-18 04.25.41" style="zoom:50%;" />

#### 函数

除以下方法之外，其他方法慎用，可能线程不安全。

- <font color=red>`put()`</font> 写入数据，阻塞（可被打断）其他写入线程，内部调用notFull.await()，会一直等待直到队列有空间，所以写入一定会成功。
- <font color=red>`take()`</font> 读取数据，阻塞（可被打断）其他读取线程，内部调用notEmpty.await()，会一直等待直到队列有数据，所以一定会读到数据。
- <font color=orange>`offer()`</font> 写入数据立即返回，可能会写入失败，因为未调用notFull.await()，阻塞（不可被打断）其他写入线程，成功返回true，否则返回false。
- <font color=orange>`offer(time, TimeUnit.SECONDS)`</font> 写入数据time时间返回，可能会写入失败，因为调用notFull.await(time)，阻塞（可被打断）其他写入线程，成功返回true，否则返回false
- <font color=orange>`add()`</font> 放数据立即返回，可能会写入失败，内部调用`offer()`，成功返回true，失败抛出异常。
- <font color=orange>`poll()`</font> 读取数据立即返回，可能会读取失败，因为未调用notEmpty.await()，阻塞（不可被打断）其他读取线程，成功返回数据，否则返回null。
- <font color=orange>`poll(2000, TimeUnit.SECONDS)`</font> 读取数据time时间返回，可能会读取失败，因为调用notEmpty.await(time)，阻塞（可被打断）其他读取线程，成功返回数据，否则返回null
- <font color=orange>`drainTo(Collection c)`</font>排空，不可打断，即读取所有数据放入集合c,并移除这些数据
- <font color=orange>`drainTo(Collection c, int maxElements)`</font>排空，不可打断，即读取maxElements个数据放入集合c,并移除这些数据
- <font color=orange>`iterator() `</font>锁，迭代器
- <font color=orange>`spliterator()`</font>
- <font color=orange>`peek() `</font>锁不可打断，只是读取元素，但是不删除元素，返回数据或者null
- <font color=orange>`contains()`</font>锁不可打断，判断是否包含
- <font color=orange>`toArray()`</font>锁不可打断，转数组
- <font color=orange>`isEmpty()`</font>锁不可打断,size() == 0 
- <font color=orange>`size()`</font>锁不可打断，返回元素个数
- <font color=orange>`remainingCapacity() `</font>锁不可打断，返回剩余容量
- <font color=orange>`remove()`</font>锁不可打断，删除某个元素
- <font color=orange>`clear()`</font>锁不可打断，删除所有元素

#### 应用场景

处理多线程间的生产者消费者问题

### SynchronousQueue

#### 特点

它非常适合于传递性设计，在这种设计中，在一个线程中运行的对象要将某些信息、事件或任务传递给在另一个线程中运行的对象，它就必须与该对象同步。

- init_capacity = max_capacity = 0
- 它一种阻塞队列，其中每个 put 必须等待一个 take，反之亦然。<font color=red>没有存储数据，消费线程是在生产线程中获取数据，如果生产线程死了，那么将获取不到数据。</font>
- 同步队列没有任何内部容量，甚至连一个队列的容量都没有
- 不允许使用 null 元素。

#### 函数

除以下方法之外，其他方法慎用，可能线程不安全

- <font color=red>`SynchronousQueue()`/`SynchronousQueue(false)`</font>：内部采用TranferStack(栈)结构，消费线程获取最后一个生产线程的数据
- <font color=red>`SynchronousQueue(true)`</font>：内部采用TranferQueue(队列)结构，消费线程获取第一个生产线程的数据
- <font color=red>`put()`</font> 放数据就一直wait直到有其他thread进来取走。
- <font color=red>`take()`</font> 取出，取不到东西他会一直等。
- <font color=orange>`offer()`</font> 放数据立即返回，如果碰巧被另一个thread取走了，offer方法返回true，认为offer成功；否则返回false。
- <font color=orange>`offer(2000, TimeUnit.SECONDS)`</font> 往queue里放一个element但是等待指定的时间后才返回，返回的逻辑和offer()方法一样。
- <font color=orange>`poll()`</font> 取出，只有到碰巧另外一个线程正在往queue里offer数据或者put数据的时候，该方法才会取到东西。否则立即返回null。
- <font color=orange>`poll(2000, TimeUnit.SECONDS)`</font> 等待指定的时间。
- <font color=orange>`drainTo(Collection c)`</font>排空，即读取所有生产线程的数据放入集合c（内部调用poll()方法，所以读完生产线程会释放，就是不会再次被读取，已经没了）
- <font color=orange>`drainTo(Collection c, int maxElements)`</font>排空，即读取maxElements个生产线程的数据放入集合c
- iterator() 永远返回空，因为里面没东西。
- peek() 永远返回null。
- isEmpty()永远是true。
- remainingCapacity() 永远是0。
- remove()永远是false。
- removeAll() 永远是false
- clear() 空方法

#### 原理

- <font color=red>`SynchronousQueue()`/`SynchronousQueue(false)`</font>：内部采用TranferStack(栈)结构，消费线程获取最后一个生产线程的数据

- <font color=red>`SynchronousQueue(true)`</font>：内部采用TranferQueue(队列)结构，消费线程获取第一个生产线程的数据

  <img src="https://i.loli.net/2021/06/21/wcrsI1L53PMKtp8.png" alt="截屏2021-06-21 18.51.54" style="zoom:50%;" />

https://www.jianshu.com/p/af6f83c78506

#### 应用场景

它的需求场景应该是这样的：消费者没拿走当前的产品，生产者是不能再给产品的。应该是为了保证消费者和生产者的节奏一致吧，其它的队列实际上有缓存的意思，比如说消费者在高峰期消费不了那么多，那么队列会缓存一部分产品，这样就不至于影响生产者的速度。

- Executors.newCachedThreadPool()就使用了SynchronousQueue，这个线程池根据需要（新任务到来时）创建新的线程，如果有空闲线程则会重复使用，线程空闲了60秒后会被回收。

### LinkedTransferQueue

#### 特点

- init_capacity = 0；max_capacity = 无限制
- LinkedTransferQueue是一个单向链表实现的无锁、可阻塞、可非阻塞、无界队列。该队列按 FIFO排序元素。
- 是`SynchronousQueue`、`ConcurrentLinkedQueue`、`LinkedBlockingQueue`等队列的超集
- LinkedTransferQueue不仅实现了普通BlockingQueue的功能, 另一个优点就是: 当有消费者等待数据时, 生产者可以直接将数据交给消费者而不是再进入队列。 与LinkedBlockingQueue相比, LinkedBlockingQueue在take和put操作时, 都是通过lock来控制, 当高并发操作take和put操作, 锁的获取和释放都是比较影响性能的。 而LinkedTransferQueue对这种使用进行了改进, 当生产者存放数据时, 发现有消费者等待消费数据, 生产者可以调用transfer直接将数据交给消费者, 而不用通过阻塞队列来传递数据, 减少了锁的释放与获取
- 为了减少head和tail的操作频率, 使用的松弛距离: head和tail不一定时刻指的队列的头和尾
- 队列不支持null元素
- 可以阻塞put线程, 此时当有当take()操作时, take线程是不会进入队列的, 而是直接将put()线程唤醒

<img src="https://i.loli.net/2021/06/21/vxDFbuRPeI7tk8K.png" alt="截屏2021-06-21 20.19.32" style="zoom: 33%;" />



#### 函数

除以下方法之外，其他方法慎用，可能线程不安全。

```java
// for untimed poll, tryTransfer  NOW就是取数据时, 发现没有数据, 线程立刻返回不追加元素到阻塞队列中等待。
private static final int NOW   = 0;
// for offer, put, add  ASYNC就是添加数据时, 若消费者来不及消费, 只是将数据放到阻塞队列中, 而线程正常返回。
//这部分是LinkedTransferQueue作为阻塞队列正常用法
private static final int ASYNC = 1;
// for transfer, take  SYNC用于消费/生产者存放/拉去数据时, 若满足不了的话, 将请求存放在阻塞队列, 同时线程也将阻塞
 //这部分是LinkedTransferQueue的特性所在
private static final int SYNC  = 2;
// for timed poll, tryTransfer  TIMED用于超时时间内读取或者存放数据时, 若满足不了的话, 将请求存放在阻塞队列, 同时线程超时阻塞。
private static final int TIMED = 3;
```

- <font color=red>`put()`</font> / <font color=orange>`offer()`</font> / <font color=orange>`offer(time, TimeUnit.SECONDS)`</font>/<font color=orange>`add()`</font>  内部代码都是xfer(e, true, ASYNC, 0)，若消费者来不及消费, 只是将数据放到阻塞队列中, 而线程正常返回
- <font color=red>`take()`</font> 拉去数据时, 若满足不了的话, 将请求存放在队列, 同时线程也将阻塞
- <font color=orange>`poll()`</font> 取数据时， 线程立刻返回，不追加元素到阻塞队列中等待
- <font color=orange>`poll(2000, TimeUnit.SECONDS)`</font> 超时时间内读取数据, 若满足不了的话, 将请求存放在阻塞队列, 同时线程超时阻塞。
- <font color=red>`transfer(E)`</font> 若当前存在一个正在等待获取的消费者线程，即立刻移交之；否则，会插入当前元素e到队列尾部，并且等待进入阻塞状态，到有消费者线程取走该元素
- <font color=red>`tryTransfer(E)`</font> 若当前存在一个正在等待获取的消费者线程（使用take()或者poll()函数），使用该方法会即刻转移/传输对象元素e；若不存在，则返回false，并且不进入队列。这是一个不阻塞的操作
- <font color=red>`tryTransfer(E,long,TimeUnit)`</font> 若当前存在一个正在等待获取的消费者线程，会立即传输给它;否则将插入元素e到队列尾部，并且等待被消费者线程获取消费掉；若在指定的时间内元素e无法被消费者线程获取，则返回false，同时该元素被移除
- <font color=orange>`drainTo(Collection c)`</font>排空，即读取所有数据放入集合c,并移除这些数据
- <font color=orange>`drainTo(Collection c, int maxElements)`</font>排空，即读取maxElements个数据放入集合c,并移除这些数据
- <font color=orange>`size()`</font>迭代统计、性能差、而且不准确、最多统计Integer.MAX_VALUE
- <font color=orange>`remainingCapacity() `</font>返回剩余容量，总是返回Integer.MAX_VALUE
- <font color=orange>`hasWaitingConsumer() `</font>判断是否存在消费者线程
- <font color=orange>`getWaitingConsumerCount() `</font>获取所有等待获取元素的消费线程数量
- <font color=orange>`iterator() `</font>迭代器
- <font color=orange>`spliterator()`</font>
- <font color=orange>`peek() `</font>
- <font color=orange>`contains()`</font>
- <font color=orange>`isEmpty()`</font>
- <font color=orange>`remove()`</font>删除某个元素
- <font color=orange>`clear()`</font>删除所有元素

#### 应用场景

是`SynchronousQueue（公平）`、`ConcurrentLinkedQueue`、`LinkedBlockingQueue`等队列功能的超集，比较万能，而且更高效、更好用。

### PriorityBlockingQueue

#### 特点

- init_capacity = initialCapacity(默认为11)；max_capacity = Integer.MAX_VALUE - 8

- 容量64以内每次扩容2个，超过64每次扩容50%

- 支持优先级排序的无界阻塞队列，按照优先级顺序出入队列，基于数组实现的堆结构，至于是最大堆还是最小堆取决于`Comparable`接口

- 不能保证相同优先级元素的顺序

- 队列不支持null元素

- 元素必须实现`Comparable`接口，或者提供比较器，否则按默认顺序。

- PriorityBlockingQueue类似于ArrayBlockingQueue内部使用一个**独占锁来控制同时只有一个线程可以进行入队和出队**，另外前者只使用了一个notEmpty条件变量而没有notFull这是因为PriorityBlockingQueue是无界队列，当put时候永远不会处于await所以也不需要被唤醒。

  <img src="https://i.loli.net/2021/06/18/UExtOFSGiLJIY5C.png" alt="截屏2021-06-18 22.37.09" style="zoom:50%;" />

#### 函数

除以下方法之外，其他方法慎用，可能线程不安全

- <font color=red>`PriorityBlockingQueue(initialCapacity,comparator)`</font>`comparator`是元素比较器
- <font color=red>`put()`</font> 与`offer()`相同。
- <font color=red>`take()`</font> 读取数据，阻塞（可被打断）其他读取线程，内部调用notEmpty.await()，会一直等待直到队列有数据，所以一定会读到数据。
- <font color=orange>`offer()`</font> 加锁(不可中断)，写入数据立即返回，一定会成功（不超过系统限制，超过也就没意义了，所以不讨论这种情况），成功返回true。
- <font color=orange>`offer(time, TimeUnit.SECONDS)`</font> 与`offer()`相同。
- <font color=orange>`add()`</font> 与`offer()`相同。
- <font color=orange>`poll()`</font> 读取数据立即返回，可能会读取失败，因为未调用notEmpty.await()，阻塞（不可被打断）其他读取线程，成功返回数据，否则返回null。
- <font color=orange>`poll(2000, TimeUnit.SECONDS)`</font> 读取数据time时间返回，可能会读取失败，因为调用notEmpty.await(time)，阻塞（可被打断）其他读取线程，成功返回数据，否则返回null
- <font color=orange>`drainTo(Collection c)`</font>锁不可打断，排空，即读取所有数据放入集合c,并移除这些数据
- <font color=orange>`drainTo(Collection c, int maxElements)`</font>锁不可打断，排空，即读取maxElements个数据放入集合c,并移除这些数据
- <font color=orange>`iterator() `</font>锁，迭代器
- <font color=orange>`spliterator()`</font>
- <font color=orange>`peek() `</font>锁不可打断，只是读取元素，但是不删除元素，返回数据或者null
- <font color=orange>`contains()`</font>锁不可打断，判断是否包含
- <font color=orange>`toArray()`</font>锁不可打断，转数组
- <font color=orange>`isEmpty()`</font>锁不可打断，size() == 0,
- <font color=orange>`size()`</font>锁不可打断，返回数据或者null，返回元素个数
- `remainingCapacity() `始终返回Integer.MAX_VALUE
- <font color=orange>`remove()`</font>锁不可打断，删除某个元素
- <font color=orange>`clear()`</font>锁不可打断，删除所有元素

#### 应用场景

- 比如发短信，通知短信和验证码短信，一般验证码短信要最快发到客户手中，通知类可以慢一点无碍，有验证码短信优先发送
- 如医院急诊科接诊要按病痛的优先级处理；构建好优先队列后逐个poll即可
- 热搜排序
- vip与普通用户购票

### DelayQueue

#### 特点

- init_capacity = initialCapacity(默认为11)；max_capacity = Integer.MAX_VALUE - 8

- 延迟无界阻塞队列，基于PriorityQueue实现，最先到期的在根结点

- 容量64以内每次扩容2个，超过64每次扩容50%

- 不能保证相同延迟时间的顺序

- 队列不支持null元素

- 元素必须实现`Delay`接口。

- DelayQueue内部使用一个**独占锁来控制同时只有一个线程可以进行入队和出队**，只使用了一个avaliable条件变量判断是否有到期任务

- 与PriorityBlockingQueue不同，扩容未采用cas锁，而是使用的全居锁

- leader为等待线程，同一时间只有一个满足条件的延时任务；当多个线程访问延迟队列时选择一个线程为leader等待，其余线程休眠，以减少不必要的cpu消耗

  <img src="https://i.loli.net/2021/06/19/XVPrt2aZ6uyOWqd.png" alt="截屏2021-06-19 02.43.55" style="zoom:50%;" />

#### 函数

除以下方法之外，其他方法慎用，可能线程不安全

- <font color=red>`put()`</font> 与`offer()`相同。
- <font color=red>`take()`</font> 读取数据，阻塞（可被打断）其他读取线程，内部调用available.await()，会一直等待直到队列有数据，所以一定会读到数据。
- <font color=orange>`offer()`</font>  加锁(不可中断)，写入数据立即返回，一定会成功（不超过系统限制，超过也就没意义了，所以不讨论这种情况），成功返回true。
- <font color=orange>`offer(time, TimeUnit.SECONDS)`</font> 与`offer()`相同。
- <font color=orange>`add()`</font> 与`offer()`相同。
- <font color=orange>`poll()`</font> 读取数据立即返回，可能会读取失败，因为未调用available.await()，阻塞（不可被打断）其他读取线程，成功返回数据，否则返回null。
- <font color=orange>`poll(2000, TimeUnit.SECONDS)`</font> 读取数据time时间返回，可能会读取失败，因为调用available.await(time)，阻塞（可被打断）其他读取线程，成功返回数据，否则返回null
- <font color=orange>`drainTo(Collection c)`</font>锁不可打断，排空，即读取所有数据放入集合c,并移除这些数据
- <font color=orange>`drainTo(Collection c, int maxElements)`</font>锁不可打断，排空，即读取maxElements个数据放入集合c,并移除这些数据
- <font color=orange>`iterator() `</font>锁，迭代器
- <font color=orange>`peek() `</font>锁不可打断，只是读取元素，但是不删除元素，返回数据或者null
- <font color=orange>`contains()`</font>锁不可打断，判断是否包含
- <font color=orange>`toArray()`</font>锁不可打断，转数组
- <font color=orange>`isEmpty()`</font>锁不可打断，size() == 0,
- <font color=orange>`size()`</font>锁不可打断，返回数据或者null，返回元素个数
- `remainingCapacity() `始终返回Integer.MAX_VALUE
- <font color=orange>`remove()`</font>锁不可打断，删除某个元素
- <font color=orange>`clear()`</font>锁不可打断，删除所有元素

#### 应用场景

- 淘宝订单业务:下单之后如果三十分钟之内没有付款就自动取消订单。 
- 关闭空闲连接。服务器中，有很多客户端的连接，空闲一段时间之后需要关闭之。
- 缓存。缓存中的对象，超过了空闲时间，需要从缓存中移出。
- 任务超时处理。在网络协议滑动窗口请求应答式交互时，处理超时未响应的请求等。

### DelayWorkQueue

#### 特点

- init_capacity = initialCapacity(默认为16)；max_capacity = Integer.MAX_VALUE

- 每次扩容50%

- 延迟无界阻塞队列，基于RunnableScheduledFuture数组的堆，最先到期的在根结点

- 不能保证相同延迟时间的顺序

- 队列不支持null元素，而且只支持线程元素

- DelayWorkQueue内部使用一个**独占锁来控制同时只有一个线程可以进行入队和出队**，只使用了一个avaliable条件变量判断是否有到期任务

- 扩容未采用cas锁，而是使用的全居锁

- leader为等待线程，同一时间只有一个满足条件的延时任务；当多个线程访问延迟队列时选择一个线程为leader等待，其余线程休眠，以减少不必要的cpu消耗

  <img src="https://i.loli.net/2021/06/19/FUPHMhJ1cudgD7y.png" alt="截屏2021-06-19 03.33.43" style="zoom:50%;" />

#### 函数

除以下方法之外，其他方法慎用，可能线程不安全

- <font color=red>`put()`</font> 与`offer()`相同。
- <font color=red>`take()`</font> 读取数据，阻塞（可被打断）其他读取线程，内部调用available.await()，会一直等待直到队列有数据，所以一定会读到数据。
- <font color=orange>`offer()`</font>  加锁(不可中断)，写入数据立即返回，一定会成功（不超过系统限制，超过也就没意义了，所以不讨论这种情况），成功返回true。
- <font color=orange>`offer(time, TimeUnit.SECONDS)`</font> 与`offer()`相同。
- <font color=orange>`add()`</font> 与`offer()`相同。
- <font color=orange>`poll()`</font> 读取数据立即返回，可能会读取失败，因为未调用available.await()，阻塞（不可被打断）其他读取线程，成功返回数据，否则返回null。
- <font color=orange>`poll(2000, TimeUnit.SECONDS)`</font> 读取数据time时间返回，可能会读取失败，因为调用available.await(time)，阻塞（可被打断）其他读取线程，成功返回数据，否则返回null
- <font color=orange>`drainTo(Collection c)`</font>锁不可打断，排空，即读取所有数据放入集合c,并移除这些数据
- <font color=orange>`drainTo(Collection c, int maxElements)`</font>锁不可打断，排空，即读取maxElements个数据放入集合c,并移除这些数据
- <font color=orange>`iterator() `</font>锁，迭代器
- <font color=orange>`peek() `</font>锁不可打断，只是读取元素，但是不删除元素，返回数据或者null
- <font color=orange>`contains()`</font>锁不可打断，判断是否包含
- <font color=orange>`toArray()`</font>锁不可打断，转数组
- <font color=orange>`isEmpty()`</font>锁不可打断，size() == 0,
- <font color=orange>`size()`</font>锁不可打断，返回数据或者null，返回元素个数
- `remainingCapacity() `始终返回Integer.MAX_VALUE
- <font color=orange>`remove()`</font>锁不可打断，删除某个元素
- <font color=orange>`clear()`</font>锁不可打断，删除所有元素

#### 应用场景

- 内部类，只在newScheduledThreadPool线程池中使用

#### DelayQueue VS DelayWorkQueue

- `DelayWorkQueue`基于RunnableScheduledFuture数组的堆；而`DelayQueue`基于PriorityQueue实现
- 初始容量不同。`DelayWorkQueue`为16，而`DelayQueue`为11
- 理论最大容量不同。`DelayWorkQueue`为Integer.MAX_VALUE，而`DelayQueue`为Integer.MAX_VALUE - 8
- 两者本质没什么区别

### ConcurrentLinkedQueue

#### 特点

- init_capacity = 0；max_capacity = 无限制
- ConcurrentLinkedQueue是一个单向链表实现的非阻塞、无锁、无界队列（cas控制），该队列按 FIFO排序元素。
- 如果判断是否有元素可以使用isEmpty()方法，千万不要用size()>0来判断是否有元素
- 入列出列线程安全，遍历不安全
- 删除节点是将item设置为null（标记为无效节点）, 队列迭代时跳过item为null节点；只有当 head 与新头节点之间的距离达到了 HOPS 指定的阀值，才会执行更新 head（也就是真正删除节点）。另一种说法，为了减少head和tail的操作频率, 使用的松弛距离: head和tail不一定时刻指的队列的头和尾。
- 队列不支持null元素

<img src="https://i.loli.net/2021/06/19/2RFgxoheNUOKyVL.png" alt="截屏2021-06-19 13.18.08" style="zoom:50%;" />

#### 函数

除以下方法之外，其他方法慎用，可能线程不安全。

- <font color=red>`offer()`</font> 写入数据，写入成功返回true。
- <font color=red>`poll()`</font> 读取数据。
- <font color=orange>`add()`</font> 同`offer()`
- <font color=orange>`addAll()`</font> 
- <font color=orange>`iterator() `</font>迭代器
- <font color=orange>`spliterator()`</font>
- <font color=orange>`peek() `</font>只是读取元素，但是不删除元素
- <font color=orange>`contains()`</font>判断是否包含
- <font color=orange>`toArray()`</font>转数组
- <font color=orange>`isEmpty()`</font>first()==null
- <font color=orange>`size()`</font>性能极差，而且不准确、最多统计Integer.MAX_VALUE
- <font color=orange>`remove()`</font>删除某个元素
- <font color=orange>`clear()`</font>删除所有元素

#### 应用场景

生产者消费者模型

更适用`消费者>生产者` 、`性能要求高`的情况，

LinkedBlockingQueue多用于任务队列
ConcurrentLinkedQueue多用于消息队列

## 双边队列

### ConcurrentLinkedDeque

#### 特点

- init_capacity = 0；max_capacity = 无限制
- ConcurrentLinkedQueue是一个双向链表实现的非阻塞、无锁、无界双端队列（cas控制）。
- 如果判断是否有元素可以使用isEmpty()方法，千万不要用size()>0来判断是否有元素
- 入列出列线程安全，遍历不安全
- 删除节点是将item设置为null（标记为无效节点）, 队列迭代时跳过item为null节点；只有当 head 与新头节点之间的距离达到了 HOPS 指定的阀值，才会执行更新 head（也就是真正删除节点）。另一种说法，为了减少head和tail的操作频率, 使用的松弛距离: head和tail不一定时刻指的队列的头和尾
- 队列不支持null元素

#### 函数

参考ConcurrentLinkedDueue，用法类似，只是分左右（类似`offerFirst()`、`offerLast()`这种的）。

#### 应用场景

双端队列最常用的地方就是实现一个长度动态变化的窗口或者连续区间

### LinkedBlockingDeque

#### 特点

- init_capacity = 0；max_capacity = capacity(默认为Integer.MAX_VALUE，受限于机器，比改值小)
- LinkedBlockingQeque是一个双向链表实现的阻塞有界双端队列，默认无界。
- 内部使用<font color=red>一个可重入锁</font>（是非公平锁，没有提供使用公平锁的选项），两个Condition
- 队列不支持null元素

#### 函数

参考LinkedBlockingQueue，用法类似，只是分左右（类似`takeFirst()`、`takeLast()`这种的）。

#### 应用场景

- 在TCP协议中，数据报有一个URG指针。正常情况下，接收者按数据包到达本机的顺序处理，而对于设置URG标志的数据报则会优先处理。正确情况下发送者按顺序将数据追加到Deque的左边，当发生紧急情况时，发送者将数据追加到Deque的右边。接收者总是从队列的右边读取数据。
- LinkedBlockingDeque可以用在“工作窃取“模式中

