# 优化原子类

## LongAdder

分段cas（类似jdk1.7concurrentHashMap分段锁的思想），性能高，sum不准确【适合监控，任务统计这种准确性要求不高的任务】。

## DoubleAdder

## LongAccumulator

加强版LongAdder，相比LongAdder的加减方法，LongAccumulator提供了一些函数计算

## DoubleAccumulator

# 原子引用

### AtomicReference

底层使用compareAndSwapObject实现CAS，比较的是两个对象的地址是否相等。也就是它可以保证你在修改对象引用时的线程安全性。

### AtomicStampedReference

版本号解决ABA问题，版本号为int类型

```java
public static void main(String[] args) {
 
        String str1 = "aaa";
        String str2 = "bbb";
        AtomicStampedReference<String> reference = new AtomicStampedReference<String>(str1,1);
        reference.compareAndSet(str1,str2,reference.getStamp(),reference.getStamp()+1);
        System.out.println("reference.getReference() = " + reference.getReference());
 
        boolean b = reference.attemptStamp(str2, reference.getStamp() + 1);
        System.out.println("b: "+b);
        System.out.println("reference.getStamp() = "+reference.getStamp());
 
        boolean c = reference.weakCompareAndSet(str2,"ccc",4, reference.getStamp()+1);
        System.out.println("reference.getReference() = "+reference.getReference());
        System.out.println("c = " + c);
    }
```

```
输出:
reference.getReference() = bbb
b: true
reference.getStamp() = 3
reference.getReference() = bbb
c = false
```

### AtomicMarkableReference

AtomicMarkableReference同AtomicStampedReference，只不过AtomicMarkableReference的版本号是boolean类型

### AtomicReferenceArray

数组原子引用。

```java
String[] source = new String[10];
AtomicReferenceArray<String> atomicReferenceArray = new AtomicReferenceArray<String>(source);
for (int i=0; i<atomicReferenceArray.length(); i++) {
         atomicReferenceArray.set(i, "item-2");
      }
```

# 原子操作属性

### AtomicReferenceFieldUpdater

原子操作属性。属性必须是引用类型，必须被volatile修饰（不要混淆，getXXXVolatile可以使普通变量有volatile语义，只是这里有别的用途）。

```java
public class AtomicReferenceFieldUpdaterTest {
    public static void main(String[] args) throws Exception  
    {  
        AtomicReferenceFieldUpdater updater=AtomicReferenceFieldUpdater.newUpdater(Dog.class,String.class,"name");  
        Dog dog=new Dog();  
        System.out.println(updater.compareAndSet(dog,"dog1","dog2"));        
        System.out.println(dog.name);  
        System.out.println(updater.getAndSet(dog, "dog3"));
        System.out.println(dog.name);
    }  
}
class Dog  
{  
    public volatile String name="dog1";  
}  
```

### AtomicIntegerFieldUpdater

与AtomicReferenceFieldUpdater类似，只不过只能更新Integer或int



