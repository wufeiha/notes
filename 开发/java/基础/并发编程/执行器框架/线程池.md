参考：https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html

# 状态

ctl   AtomicInteger 类型。高3位存储线程池状态，低29位存储当前线程数量

- `RUNNING` 自然是运行状态，指可以接受任务执行队列里的任务
- `SHUTDOWN` 指调用了 `shutdown()` 方法，不再接受新任务了，但是队列里的任务得执行完毕。
- `STOP` 指调用了 `shutdownNow()` 方法，不再接受新任务，同时抛弃阻塞队列里的所有任务并中断所有正在执行任务。
- `TIDYING` 所有任务都执行完毕，在调用 `shutdown()/shutdownNow()` 中都会尝试更新为这个状态。
- `TERMINATED` 终止状态，当执行 `terminated()` 后会更新为这个状态。
![img](https://i.loli.net/2021/06/27/n3UMYFusRVagQKT.jpg)


# 优势

1. 降低系统资源消耗，提高系统响应速度，通过重用已存在的线程，降低线程创建和销毁造成的消耗；
3. 方便线程并发数的管控。因为线程若是无限制的创建，可能会导致内存占用过多而产生OOM，并且会造成cpu过度切换
4. 提供更强大的功能，延时定时线程池。

# 主要参数

1. **`corePoolSize（线程池基本大小）`**：当向线程池提交一个任务时，若线程池已创建的线程数小于corePoolSize，即便此时存在空闲线程，也会通过创建一个新线程来执行该任务，直到已创建的线程数大于或等于corePoolSize时，（除了利用提交新任务来创建和启动线程（按需构造），也可以通过 prestartCoreThread() 或 prestartAllCoreThreads() 方法来提前启动线程池中的基本线程。）
2. **`maximumPoolSize（线程池最大大小）`**：线程池所允许的最大线程个数。当队列满了，且已创建的线程数小于maximumPoolSize，则线程池会创建新的线程来执行任务。另外，对于无界队列，可忽略该参数。
3. **`keepAliveTime（线程存活保持时间）`**:当线程池中线程数大于核心线程数时，线程的空闲时间如果超过线程存活时间，那么这个线程就会被销毁，直到线程池中的线程数小于等于核心线程数。
4. **`workQueue（任务队列）`**：用于传输和保存等待执行任务的阻塞队列。
5. **`threadFactory（线程工厂）`**：用于创建新线程。threadFactory创建的线程也是采用new Thread()方式，threadFactory创建的线程名都具有统一的风格：pool-m-thread-n（m为线程池的编号，n为线程池内的线程编号）。
6. **`handler（线程饱和策略）`**：当线程池和队列都满了，再加入线程会执行此策略。

# 流程

![image-20210616162601134](https://i.loli.net/2021/06/16/HSVNFgnxqP8iYOy.png)

如果queue.poll(keepAliveTime)获取不到数据，则会减少非coreThreads的数量。

# 线程池种类



|         线程池          | corePoolSize |  maximumPoolSize  | keepAliveTime |      workQueue      | 用途                                                         | 注意 |
| :---------------------: | :----------: | :---------------: | :-----------: | :-----------------: | :----------------------------------------------------------- | ---- |
|   newCachedThreadPool   |      0       | Integer.MAX_VALUE |      60s      |  SynchronousQueue   | newCachedThreadPool：用来创建一个可以无限扩大的线程池，适用于负载较轻的场景，执行短期异步任务。（可以使得任务快速得到执行，因为任务时间执行短，可以很快结束，也不会造成cpu过度切换） |      |
|   newFixedThreadPool    |   nThreads   |     nThreads      |       0       | LinkedBlockingQueue | newFixedThreadPool：创建一个固定大小的线程池，因为采用无界的阻塞队列，所以实际线程数量永远不会变化，适用于负载较重的场景，对当前线程数量进行限制。（保证线程数可控，不会造成线程过多，导致系统负载更为严重） |      |
| newSingleThreadExecutor |      1       |         1         |       0       | LinkedBlockingQueue | newSingleThreadExecutor：创建一个单线程的线程池，适用于需要保证顺序执行各个任务。 |      |
| newScheduledThreadPool  | corePoolSize | Integer.MAX_VALUE |       0       |  DelayedWorkQueue   | newScheduledThreadPool：适用于执行延时或者周期性任务。       |      |

# 拒绝策略

![undefined](https://i.loli.net/2021/06/27/AGCZwD6IjOgHcxr.png)

| 拒绝策略            | 拒绝行为                                               |
| ------------------- | ------------------------------------------------------ |
| AbortPolicy         | 抛出RejectedExecutionException，需要自己处理           |
| DiscardPolicy       | 什么也不做，直接忽略                                   |
| DiscardOldestPolicy | 执行queue.poll()获取任务但不执行，反而执行新加入的任务 |
| CallerRunsPolicy    | 直接由提交任务者线程执行这个任务                       |

# 方法

## execute()和submit()方法

1、execute()，执行一个任务，没有返回值。
 2、submit()，提交一个线程任务，有返回值。
 submit(Callable<T> task)能获取到它的返回值，通过future.get()获取（阻塞直到任务执行完）。一般使用FutureTask+Callable配合使用（IntentService中有体现）。

submit(Runnable task, T result)能通过传入的载体result间接获得线程的返回值。
 submit(Runnable task)则是没有返回值的，就算获取它的返回值也是null。

Future.get方法会使取结果的线程进入阻塞状态，知道线程执行完成之后，唤醒取结果的线程，然后返回结果。

## pool.awaitTermination(1, TimeUnit.SECONDS)

```java
while (!pool.awaitTermination(1, TimeUnit.SECONDS)) {
    LOGGER.info("线程还在执行。。。");
}
```

`pool.awaitTermination(1, TimeUnit.SECONDS)` 会每隔一秒钟检查一次是否执行完毕（状态为 `TERMINATED`），当从 while 循环退出时就表明线程池已经完全终止了。

# FAQ

## 线程池为什么需要使用（阻塞）队列？

回到了非线程池缺点中的第3点：
 1、因为线程若是无限制的创建，可能会导致内存占用过多而产生OOM，并且会造成cpu过度切换。

另外回到了非线程池缺点中的第1点：
 2、创建线程的消耗较高。
 或者下面这个网上并不高明的回答：
 2、线程池创建线程需要获取mainlock这个全局锁，影响并发效率，阻塞队列可以很好的缓冲。

## 线程池为什么要使用阻塞队列而不使用非阻塞队列？

阻塞队列可以保证任务队列中没有任务时阻塞获取任务的线程，使得线程进入wait状态，释放cpu资源。
 当队列中有任务时才唤醒对应线程从队列中取出消息进行执行。
 使得在线程不至于一直占用cpu资源。

（线程执行完任务后通过循环再次从任务队列中取出任务进行执行，代码片段如下
 while (task != null || (task = getTask()) != null) {}）。

阻塞队列一定程度上可以平衡生产者、消费者的速度。

## 如何配置线程池数量

### 按硬件限制

#### CPU密集型任务

 <font color=orange>尽量使用较小的线程池，一般为CPU核心数+1。</font> 因为CPU密集型任务使得CPU使用率很高，若开过多的线程数，会造成CPU过度切换，           （即使当计算密集型的线程，偶尔由于页缺失故障或者其他原因阻塞时，这个“额外” 的线程也能确保CPU 的时钟周期不会被浪费。）

#### IO密集型任务

  <font color=orange>可以使用稍大的线程池，一般为2*CPU核心数+1。</font> IO密集型任务CPU使用率并不高，因此可以让CPU在等待IO的时候有其他线程去处理别的任务，充分利用CPU时间。

最佳线程数目 = （（线程等待时间+线程CPU时间）/线程CPU时间 ）* CPU数目

#### 混合型任务

可以将任务分成IO密集型和CPU密集型任务，然后分别用不同的线程池去处理。 只要分完之后两类任务的执行时间相差不大，那么就会比单个线程池执行来的高效。如果划分之后两任务执行时间有数据级的差距，那么拆分没有意义，而且还要加上任务拆分与合并的开销，得不偿失。

### 按业务需求

参考：https://www.jianshu.com/p/2a80237c3c60

需要根据几个值来决定

> tasks ：每秒的任务数，假设为500~1000
>
> taskcost：每个任务花费时间，假设为0.1s
>
> responsetime：系统允许容忍的最大响应时间，假设为1s

- corePoolSize = tasks/(1/taskcost) =tasks*taskcout = (500~1000)*0.1 = 50~100 个线程。corePoolSize设置应该大于50根据8020原则，如果80%的每秒任务数小于800，那么corePoolSize设置为80即可
- queueCapacity = (coreSizePool/taskcost)*responsetime，计算可得 queueCapacity = $80/0.1 * 1$ = 800。意思是队列里的线程可以等待1s，超过了的需要新开线程来执行
- maxPoolSize = (maxtasks- queueCapacity)/(1/taskcost)，计算可得 maxPoolSize = (1000-800)/10 = 20，（最大任务数-队列容量）/每个线程每秒处理能力 = 最大线程数
- rejectedExecutionHandler：根据具体情况来决定，任务不重要可丢弃，任务重要则要利用一些缓冲机制来处理
- keepAliveTime采用默认通常能满足

## 注意

- 不要使用Executors创建线程池，而是使用对应线程池的构造函数【更灵活，更易控制】
- 因为任务会共享线程，所以ThreadLocal可能会出现混乱，使用完要清理，即使用ThreadLocal.remove()

