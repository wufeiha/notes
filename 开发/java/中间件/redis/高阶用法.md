<font color =red>注意：以下所说的原子性不是真正的原子性，redis事务或者lua脚本执行中某些命令失败并不会导致其他正常命令回滚。</font>

## pipeline

### 特点

- <font color =red>**集群模式下，只能作用在一个Redis节点上，不能操作跨节点的键**</font>
- pipeline 每批打包的命令不能过多，因为 pipeline 方式打包命令再发送，那么 redis 必须在处理完所有命令前先缓存起所有命令的处理结果。这样就有一个内存的消耗。可以将大的pipeline拆分成小的pipeline
- pipeline不保证原子性。
- 有些系统可能对可靠性要求很高，每次操作都需要立马知道这次操作是否成功，是否数据已经写进redis了，那这种场景就不适合

#### 普通请求

<img src="https://i.loli.net/2021/08/02/hTwriEO1ySp8q3Y.jpg" alt="img" style="zoom:50%;" />

#### pipeline请求

<img src="https://i.loli.net/2021/08/02/whWksLzXu7mFPRt.jpg" alt="img" style="zoom:35%;" />

<img src="https://i.loli.net/2021/08/02/lTLY2t7qxPiwOXV.jpg" alt="img" style="zoom:37%;" />

## 事务

### 特点

- multi(开启事务) &rarr; 命令... &rarr;  exec  &rarr;（执行事务） 

  ![img](https://i.loli.net/2021/08/02/DsP3WE8wgcj7Tko.png)

- 当我们想取消事务的时候就可以使用 discard丢弃当前事务，这个命令要在exec前执行，因为redis没有回滚的概念

- redis事务不支持回滚，因为Redis认为失败都是使用者造成的所以就没有回滚操作

- 虽然redis不支持直接回滚，但是watch机制实现乐观锁解决相关key被其他客户端进行回滚

- <font color =red>**集群模式下，只能作用在一个Redis节点上，不能操作跨节点的键**</font>

### redis事务出错原因

- 事务在执行 [EXEC](https://link.jianshu.com?t=http%3A%2F%2Fredisdoc.com%2Ftransaction%2Fexec.html%23exec) 之前，入队的命令可能会出错。比如说，命令可能会产生语法错误（参数数量错误，参数名错误，等等），或者其他更严重的错误，比如内存不足（如果服务器使用 `maxmemory` 设置了最大内存限制的话）。
- 命令可能在 [EXEC](https://link.jianshu.com?t=http%3A%2F%2Fredisdoc.com%2Ftransaction%2Fexec.html%23exec) 调用之后失败。举个例子，事务中的命令可能处理了错误类型的键，比如将列表命令用在了字符串键上面，诸如此类。

### watch机制

- 该命令可以为 Redis事务提供 check-and-set （CAS）行为。
- watch要在事务开启之前就监控不然会报错。
- 可以使用 `watch`命令来监视一个 或多个key，如果被监视的 key在事务执行前被修改过那么本次事务将会被取消，也就是所谓的回滚
- watch是一次性的。如果一次事务中存在被监视的 key，无论此次事务执行成功与否，该 key的监视都将会在执行后失效 也就是说监视是一次性的。

![img](https://i.loli.net/2021/08/02/rYh26yJ7EKtGeOn.jpg)

## lua

### 特点

- redis lua不可定义全局变量
- 执行原子性【redis 执行脚本是单线程的，执行期间不会执行其他的脚本和命令】
- 脚本任务不易过重，否则将会影响其他脚本或命令执行
- 为了节省带宽，lua脚本会缓存在redis中
- 减少网络开销。可以将多个请求通过脚本的形式一次发送，减少网络时延
- <font color =red>**集群模式下，只能作用在一个Redis节点上，不能操作跨节点的键**</font>

### redis-lua脚本内调用redis命令的方式

- **`redis-call()`**    在执行命令的过程中发生错误时，脚本会停止执行，并返回一个脚本错误，错误的输出信息会说明错误造成的原因.
- **`redis.pcall()`**    出错时并不引发(raise)错误，而是返回一个带 err 域的 Lua 表(table)，用于表示错误

### redis操作脚本的方式

- **`eval`** eval script numkeys key [key ...] arg [arg ...]

- **`evalsha`**与eval类似，只不过是通过sha码来调用脚本。eval scriptsha numkeys key [key ...] arg [arg ...]

- **`script load`**       将脚本 script 添加到脚本缓存中，但并不立即执行这个脚本。**EVAL 命令也会将脚本添加到脚本缓存中**，但是它会**立即对输入的脚本**进行求值。如果给定的脚本已经在缓存里面了，那么不做动作。在脚本被加入到缓存之后，通过 EVALSHA 命令，可以使用脚本的 SHA1 校验和来调用这个脚本。脚本可以在缓存中保留无限长的时间，直到执行 SCRIPT FLUSH 为止。

- **`script exists`**    判断脚本是否已经添加到缓存中去了，1代表已经添加，0代表没有添加

- **`script kill`**    杀死当前正在运行的 Lua 脚本，当且仅当这个脚本没有执行过任何写操作时，这个命令才生效
  - 这个命令主要用于终止运行时间过长的脚本，比如一个因为 BUG 而发生无限 loop 的脚本。SCRIPT KILL 执行之后，当前正在运行的脚本会被杀死，执行这个脚本的客户端会从EVAL 命令的阻塞当中退出，并收到一个错误作为返回值。
  - 假如当前正在运行的脚本已经执行过写操作，那么即使执行 SCRIPT KILL ，也无法将它杀死，因为这是违反 Lua 脚本的原子性执行原则的。在这种情况下，唯一可行的办法是使用 SHUTDOWN NOSAVE 命令，通过停止整个 Redis 进程来停止脚本的运行，并防止不完整(half-written)的信息被写入数据库中。
  
- **`script flush`**     清除所有 Lua 脚本缓存

### <font color=red>可能出现的异常</font>

## 事务与lua脚本的区别

- <font color =red>lua中发生异常处理方式和redis 事务一致,可以说这两个东西是一样的，但是lua支持缓存，可以复用脚本，这个是原来的事务所没有的</font>
- <font color =red>事务是多次请求一次返回，lua是一次请求</font>

## 事务与pipeline的区别

- pipeline是客户端的行为，pipeline是客户端缓冲。pipeline是客户端将执行的命令写入到缓冲中，最后由exec命令一次性发送给redis执行返回。对于服务器来说是透明的，可以认为服务器无法区分客户端发送来的查询命令是以普通命令的形式还是以pipeline的形式发送到服务器的。pipeline是通过管道一个个的去执行命令,在redis的客户端做缓冲,减少了redis的连接与请求量,减轻了redis的压力,但是结果依然是按顺序一个个执行,并不具有原子性
- 而事务则是实现在服务器端的行为，事务是服务端缓冲。用户执行MULTI命令时，服务器会将对应这个用户的客户端对象设置为一个特殊的状态，在这个状态下后续用户执行的查询命令不会被真的执行，而是被服务器缓存起来，直到用户执行EXEC命令为止，服务器会将这个用户对应的客户端对象中缓存的命令按照提交的顺序依次执行。
- multi/exec可以保证原子性，而pipeline不保证原子性
- <font color =red>请求次数的不一致。pipeline一次请求一次返回，事务是多次请求一次返回。某些客户端支持pi peline的事务，即达到一次请求一次返回事务的效果</font>

## 参考资料

1. [Redis 脚本、Lua语法学习](https://www.cnblogs.com/yaopengfei/p/13941841.html)
2. [Redis Lua实战](https://www.jianshu.com/p/366d1b4f0d13)
3. [为什么redis事务不支持回滚](https://zhuanlan.zhihu.com/p/358797470)

