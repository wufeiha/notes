- 尽量避免`NULL`。
- 谨慎使用enum，但是使用枚举容易混乱不便后期的修改，枚举属性只能追加不能修改原有的属性值和顺序，否则会导致重建整个表
- 避免使用bit类型，innodb为每个bit列使用一个足够小的整数类型，所以不能节省存储空间。如果想使用一个bit的空间存储boolean值，可以创建一个可以为空的char(0) 列，改列可以存储"",NULL两个值。或者可以将java中多个bit值打包，使用位运算操作。
- 尽量避免使用字符串做主键。尤其是毫无规律的随机字符串
- 如果存储UUID值，应移除‘-’符号，最好用UNHEX()函数转换UUID值为16字节的数字，存储为BINARY(16)列中，检索时通过HEX()函数格式化为16进制。
- 使用无符号整数存储IPv4地址，使用INET_ATON与INET_NTOA进行转换
- 关联条件尽量使用相同类型的列

## 数字类型

- decimal(m,d) 占用字节数为 m+2；M 的范围是65，
  D 的范围是30

  | Leftover Digits | Number of bypes |
  | --------------- | --------------- |
  | 0               | 0               |
  | 1-2             | 1               |
  | 3-4             | 2               |
  | 5-6             | 3               |
  | 7-8             | 4               |

  - 字段decimal(18,9)，整数4byte，小数4byte，小数点1byte，共9byte
  - 字段decimal(20,6) ，整数7byte，小数3byte，小数点1byte，共11byte

- 数据量比较大的时候，可以考虑使用BIGINT类型代替DECIMAL类型，将需要存储的货币单位根据小数的位数乘以相应的倍数即可。假设要存储财务数据精确到万分之一，可以把所有金额乘以一百万，然后将结果存储在BIGINT里。这样可以同时避免浮点存储计算不精确和DECIMAL精确计算代价高的问题

## 字符串类型

- 字符串的最大长度比平均长度大很多，列更新很少，可以无视由更新产生的碎片问题，就使用varchar类型
- varchar想比于char需要多余的空间存储长度信息

## 时间类型

- datetime，范围1001-9999，精确到秒，没有时区概念，8字节存储空间
- timestamp，范围1970-2038，精确到秒，有时区概念，4字节存储空间，推荐使用。
- 如果需要精确到毫秒、微妙级别，将时间戳存储为bigint即可。



