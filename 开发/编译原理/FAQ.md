### gcc，clang，llvm之间的关系

- gcc是全段编译器，包括前端和后端，但是组件杂糅在一起难以复用
- clang是llvm编译前端
- llvm是编译后端

### c语言编译过程及各种中间文件、执行过程

- xxx.c【源文件】---预处理--->xxx.i----编译--->xxx.s【汇编语言】----汇编---->xxx.o【二进制机器码】---链接----->xxx.out【二进制可执行机器码】

- 加载器加载  xxx.out，这个还不清楚

编译过程中间态根据编译器不同不一定全部经过，例如使用`llvm`编译器有可能`llvm ir`文件直接编译成xxx.o机器码，有兴趣以后再看

### 汇编是指令集吗

显然不是，大部分可以一对一翻译成指令集【比如计算逻辑】，但是像涉及屏幕成像、读写硬盘/网卡等操作外部硬件需要通过系统调用【操作系统内核及内核中的驱动】来完成。

### 可执行程序是指令集吗

是二进制机器码，里面包含数据段、CPU指令集、系统调用等。

### 内核态、用户态、虚拟地址、物理地址答疑、寄存器权限

- 内核态、用户态是操作系统区分的，操作系统内核工作在CPU R0级别，用户态工作在CPU R3级别。
- cpu R0权限移交【bios--->bootloader----->操作系统】，操作系统内核将以后的程序级别都调为R3
- 无论内核态还是用户态在有MMU的CPU中操作的都是虚拟内存地址，Linux只能运行在有MMU的CPU中，但是可以修改程序，使其直接操作物理地址，运行在无MMU的芯片中，但是有局限性。
- 有些操作系统直接访问物理地址，MMU虽然是硬件，好像可以关掉
- 用户态可以访问一些寄存机，有些寄存器只有内核态可以访问
- 单片机一般无MMU，操作的都是物理内存地址，可以直接操作寄存器，结构简单，一般也不需要操作系统。实在需要也许可以刷入一些简单的操作系统

### 同一cpu架构下可执行程序不能跨操作系统运行的原因

不同操作系统能识别的可执行文件的文件结构【程序段、数据段等】是不一样的，没有办法在一个操作系统上执行不符合它【可执行文件结构标准】的程序的。 
程序可能调用了一个操作系统提供的系统调用/内核API（或者封装了系统调用/内核API的库），这样的程序是没法在另一个操作系统上执行的，因为在另一个操作系统上没有这样的系统调用/内核API。